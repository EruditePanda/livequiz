class LiveQuiz
    constructor: () ->

      @heartbeat = 20

      @uuid = gon.participant.authorization_key
      @auth_key = @uuid
      @session_key = gon.session_key
      @participant = gon.participant
      
      @client_channel = @session_key+"-client"
      @server_channel = @session_key+"-server"
      @chat_channel = @session_key+"-chat"

      @pubnub = PUBNUB(
          publish_key: '<%= ENV.fetch('PUBNUB_PUBLISH_KEY') %>'
          subscribe_key: '<%= ENV.fetch('PUBNUB_SUBSCRIBE_KEY') %>'
          auth_key: @auth_key
          uuid: @uuid
          origin: 'pubsub.pubnub.com'
          ssl: true
      )

      @subscribeToChatChannel()
      @subscribeToServerChannel()
      @whoIsHereNow()

    whoIsHereNow: ->

      @pubnub.here_now
        channel: @chat_channel
        state: true
        callback: (m) =>
          uuids_with_status = _.map(m.uuids, (uuid) -> 
              { uuid: uuid.uuid, status: 'online', name: uuid.state.name, email: uuid.state.email }
          )
          React.render(<ParticipantsList participants=uuids_with_status />, @react('ParticipantsList'))  

    ###################### SUSCRIBE #########################

    subscribeToChatChannel: ->

      @pubnub.subscribe(
        channel: @chat_channel
        state:
          name: @participant.name
          email: @participant.email
        message: ->
        presence: @presenceCallback
        connect: ->
        heartbeat: 20
      )

    subscribeToServerChannel: ->
        
        @pubnub.subscribe(
          channel: @server_channel
          message: @serverCallback
          connect: ->
        )

    ###################### CALLBACKS #########################

    presenceCallback: (event_message, env, ch, timer, magic_ch) =>

      React.render(<ActivityFeed newActivity=event_message />, @react('ActivityFeed'))
      
      status = switch event_message.action
          when 'leave' then 'offline'
          when 'timeout' then 'offline'
          when 'join' then 'online'

      if status?
          uuid_with_status = [{uuid: event_message.uuid, status: status, name: event_message.data.name, email: event_message.data.email}]
          React.render(<ParticipantsList participants=uuid_with_status />, @react('ParticipantsList')) 

    serverCallback: (event_message, env, ch, timer, magic_ch) =>
      switch(event_message.event)
        when 'question' then React.render(<QuestionDisplay question=event_message.data.question />, @react('QuestionDisplay'))
        when 'answered'
          message = { 
                      action: event_message.event,
                      timestamp: event_message.data.timestamp, 
                      uuid: event_message.data.uuid, 
                      data:  
                        name: event_message.data.name
                        correct: event_message.data.correct
                    }
          React.render(<ActivityFeed newActivity=message />, @react('ActivityFeed'))
          if event_message.data.uuid == @uuid
            if event_message.data.correct
              React.render(<CorrectAnswer />, @react('QuestionDisplay'))
            else
              React.render(<WrongAnswer />, @react('QuestionDisplay'))

        when 'results' then React.render(<ResultsDisplay results=event_message.data.results />, @react('QuestionDisplay')) 
      
    ##################### CLIENT COMMANDS ###################

    answerQuestion: (id) ->
      @sendEvent('answer', {answer_id: id})


    sendEvent: (event, data) ->
      @pubnub.publish
        channel: @client_channel        
        message: { event: event, auth_key: @auth_key, data: data}
        callback : ->

   ##################### UTILITIES ########################
   
   # Fetch a react component from the react name
    react: (react_name) ->
      $("[data-react-class=#{react_name}]").get(0)

@liveQuiz = new LiveQuiz()   